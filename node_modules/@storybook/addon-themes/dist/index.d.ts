declare global {
	interface SymbolConstructor {
		readonly observable: symbol;
	}
}

interface SBBaseType {
    required?: boolean;
    raw?: string;
}
type SBScalarType = SBBaseType & {
    name: 'boolean' | 'string' | 'number' | 'function' | 'symbol';
};
type SBArrayType = SBBaseType & {
    name: 'array';
    value: SBType;
};
type SBObjectType = SBBaseType & {
    name: 'object';
    value: Record<string, SBType>;
};
type SBEnumType = SBBaseType & {
    name: 'enum';
    value: (string | number)[];
};
type SBIntersectionType = SBBaseType & {
    name: 'intersection';
    value: SBType[];
};
type SBUnionType = SBBaseType & {
    name: 'union';
    value: SBType[];
};
type SBOtherType = SBBaseType & {
    name: 'other';
    value: string;
};
type SBType = SBScalarType | SBEnumType | SBArrayType | SBObjectType | SBIntersectionType | SBUnionType | SBOtherType;

type StoryId = string;
type ComponentId = string;
type ComponentTitle = string;
type StoryName = string;
type Tag = string;
interface StoryIdentifier {
    componentId: ComponentId;
    title: ComponentTitle;
    /** @deprecated */
    kind: ComponentTitle;
    id: StoryId;
    name: StoryName;
    /** @deprecated */
    story: StoryName;
    tags: Tag[];
}
interface Parameters {
    [name: string]: any;
}
type ConditionalTest = {
    truthy?: boolean;
} | {
    exists: boolean;
} | {
    eq: any;
} | {
    neq: any;
};
type ConditionalValue = {
    arg: string;
} | {
    global: string;
};
type Conditional = ConditionalValue & ConditionalTest;
interface InputType {
    name?: string;
    description?: string;
    defaultValue?: any;
    type?: SBType | SBScalarType['name'];
    if?: Conditional;
    [key: string]: any;
}
interface StrictInputType extends InputType {
    name: string;
    type?: SBType;
}
interface Args {
    [name: string]: any;
}
type StrictArgTypes<TArgs = Args> = {
    [name in keyof TArgs]: StrictInputType;
};
interface Globals {
    [name: string]: any;
}
type Renderer = {
    /** What is the type of the `component` annotation in this renderer? */
    component: unknown;
    /** What does the story function return in this renderer? */
    storyResult: unknown;
    /** What type of element does this renderer render to? */
    canvasElement: unknown;
    T?: unknown;
};
interface StoryContextForEnhancers<TRenderer extends Renderer = Renderer, TArgs = Args> extends StoryIdentifier {
    component?: (TRenderer & {
        T: any;
    })['component'];
    subcomponents?: Record<string, (TRenderer & {
        T: any;
    })['component']>;
    parameters: Parameters;
    initialArgs: TArgs;
    argTypes: StrictArgTypes<TArgs>;
}
interface StoryContextUpdate<TArgs = Args> {
    args?: TArgs;
    globals?: Globals;
    [key: string]: any;
}
type ViewMode$1 = 'story' | 'docs';
interface StoryContextForLoaders<TRenderer extends Renderer = Renderer, TArgs = Args> extends StoryContextForEnhancers<TRenderer, TArgs>, Required<StoryContextUpdate<TArgs>> {
    hooks: unknown;
    viewMode: ViewMode$1;
    originalStoryFn: StoryFn<TRenderer>;
}
interface StoryContext<TRenderer extends Renderer = Renderer, TArgs = Args> extends StoryContextForLoaders<TRenderer, TArgs> {
    loaded: Record<string, any>;
    abortSignal: AbortSignal;
    canvasElement: TRenderer['canvasElement'];
}
type PartialStoryFn<TRenderer extends Renderer = Renderer, TArgs = Args> = (update?: StoryContextUpdate<Partial<TArgs>>) => TRenderer['storyResult'];
type LegacyStoryFn<TRenderer extends Renderer = Renderer, TArgs = Args> = (context: StoryContext<TRenderer, TArgs>) => TRenderer['storyResult'];
type ArgsStoryFn<TRenderer extends Renderer = Renderer, TArgs = Args> = (args: TArgs, context: StoryContext<TRenderer, TArgs>) => (TRenderer & {
    T: TArgs;
})['storyResult'];
type StoryFn<TRenderer extends Renderer = Renderer, TArgs = Args> = LegacyStoryFn<TRenderer, TArgs> | ArgsStoryFn<TRenderer, TArgs>;
type DecoratorFunction<TRenderer extends Renderer = Renderer, TArgs = Args> = (fn: PartialStoryFn<TRenderer, TArgs>, c: StoryContext<TRenderer, TArgs>) => TRenderer['storyResult'];

interface ClassNameStrategyConfiguration {
    themes: Record<string, string>;
    defaultTheme: string;
    parentSelector?: string;
}
declare const withThemeByClassName: <TRenderer extends Renderer = Renderer>({ themes, defaultTheme, parentSelector, }: ClassNameStrategyConfiguration) => DecoratorFunction<TRenderer>;

interface DataAttributeStrategyConfiguration {
    themes: Record<string, string>;
    defaultTheme: string;
    parentSelector?: string;
    attributeName?: string;
}
declare const withThemeByDataAttribute: <TRenderer extends Renderer = Renderer>({ themes, defaultTheme, parentSelector, attributeName, }: DataAttributeStrategyConfiguration) => DecoratorFunction<TRenderer>;

type Theme = Record<string, any>;
type ThemeMap = Record<string, Theme>;
interface ProviderStrategyConfiguration {
    Provider?: any;
    GlobalStyles?: any;
    defaultTheme?: string;
    themes?: ThemeMap;
}
declare const withThemeFromJSXProvider: <TRenderer extends Renderer = Renderer>({ Provider, GlobalStyles, defaultTheme, themes, }: ProviderStrategyConfiguration) => DecoratorFunction<TRenderer>;

interface ThemeParameters {
    themeOverride?: string;
}

/**
 *
 * @param StoryContext
 * @returns The global theme name set for your stories
 */
declare function pluckThemeFromContext({ globals }: StoryContext): string;
declare function useThemeParameters(): ThemeParameters;
declare function initializeThemeState(themeNames: string[], defaultTheme: string): void;

declare const helpers_initializeThemeState: typeof initializeThemeState;
declare const helpers_pluckThemeFromContext: typeof pluckThemeFromContext;
declare const helpers_useThemeParameters: typeof useThemeParameters;
declare namespace helpers {
  export {
    helpers_initializeThemeState as initializeThemeState,
    helpers_pluckThemeFromContext as pluckThemeFromContext,
    helpers_useThemeParameters as useThemeParameters,
  };
}

declare const _default: {};

export { ClassNameStrategyConfiguration, DataAttributeStrategyConfiguration, helpers as DecoratorHelpers, ProviderStrategyConfiguration, _default as default, withThemeByClassName, withThemeByDataAttribute, withThemeFromJSXProvider };
